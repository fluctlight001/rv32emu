# RISC-V RV32I[MAFC] 模拟器
![GitHub Actions](https://github.com/sysprog21/rv32emu/actions/workflows/main.yml/badge.svg)
```
                       /--===============------\
      ______     __    | |⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺|     |
     |  _ \ \   / /    | |               |     |
     | |_) \ \ / /     | |   Emulator!   |     |
     |  _ < \ V /      | |               |     |
     |_| \_\ \_/       | |_______________|     |
      _________        |                   ::::|
     |___ /___ \       '======================='
       |_ \ __) |      //-'-'-'-'-'-'-'-'-'-'-\\
      ___) / __/      //_'_'_'_'_'_'_'_'_'_'_'_\\
     |____/_____|     [-------------------------]
```

`rv32emu` 是一个 32 位 [RISC-V 处理器模型](https://riscv.org/technical/specifications/) (RV32),
忠实实现了 RISC-V 指令集架构 (ISA).
作为一个对现代RISC处理器的建模练习，它的设备操作并没有像硬件实现那么复杂。
该项目旨在易于学习和扩展，希望其能够成为理想的教学工具和定制化工具的基础。
该代码主要使用 C99 标准进行书写，注重效率和易读性。

特性:
* 能够快速执行 RV32 ISA 的解释器
* 全面支持 RV32I 及 M、A、F、C 扩展
* 内存高利用率设计
* 内置 ELF loader
* 使用 newlib 系统调用实现
* 用于运行视频游戏的基于 SDL 的实验性显示/事件/音频系统调用
* 支持远程 GDB 调试
* 实验性 JIT 编译器，可在保持较小占用空间的同时提高性能

## Build and Verify

`rv32emu` 依赖于某些第三方软件包来获得完整的功能和特性。为确保正确执行，目标系统应已安装
 [SDL2 library](https://www.libsdl.org/) 
和 [SDL2_Mixer library](https://wiki.libsdl.org/SDL2_mixer) 。
* macOS: `brew install sdl2 sdl2_mixer`
* Ubuntu Linux / Debian: `sudo apt install libsdl2-dev libsdl2-mixer-dev`

构建模拟器：
```shell
$ make
```

运行示例 RV32I[M] 程序:
```shell
$ make check
```

通过 `rv32emu` 运行 [Doom](https://en.wikipedia.org/wiki/Doom_(1993_video_game)) , 一个经典的视频游戏:
```shell
$ make doom
```

构建脚本将自动下载 Doom 的数据文件。
加载并运行 Doom 时，应该会出现一个基于SDL2的窗口。

如果启用了 RV32F 支持 (默认开启), [Quake](https://en.wikipedia.org/wiki/Quake_(series)) 演示程序可以通过以下方式启动：
```shell
$ make quake
```

Doom 和 Quake 的演示程序的用法和限制在 [docs/demo.md](docs/demo.md) 中列出.

### Docker image

The image containing all the necessary tools for development and testing can be executed by `docker run -it sysprog21/rv32emu:latest`. It works for both x86-64 and aarch64 (Apple's M1 chip) machines.

### 客制化

`rv32emu` 是可配置的，您可以覆盖以下变量以实现您的需求:
* `ENABLE_EXT_M`: M 扩展，用于整数乘除法指令的标准扩展
* `ENABLE_EXT_A`: A 扩展，用于原子指令的的标准扩展
* `ENABLE_EXT_F`: F 扩展，用于单精度浮点指令的标准扩展
* `ENABLE_EXT_C`: C 扩展，用于压缩指令的标准扩展( RV32C.D 除外 )
* `ENABLE_Zicsr`: Zicsr 扩展，控制和状态寄存器 ( CSR )
* `ENABLE_Zifencei`: Zifencei 扩展，取指围栏，同步指令流和数据流
* `ENABLE_GDBSTUB` : GDB 远程调试支持
* `ENABLE_SDL` : SDL 支持，实验性显示和事件系统调用
* `ENABLE_JIT` : 实验性 JIT 编译器

例：执行 `make ENABLE_EXT_F=0` 以构建没有浮点支持的程序。

或者，通过执行 `make config` 和在配置文件中指定这些选项。随后，根据提供的配置运行 `make` 。
例如，使用一下命令：
```shell
$ make config ENABLE_SDL=0
$ make
```

### RISCOF

[RISCOF](https://github.com/riscv-software-src/riscof) (RISC-V Compatibility Framework) is
a Python based framework that facilitates testing of a RISC-V target against a golden reference model.

The RISC-V Architectural Tests, also known as [riscv-arch-test](https://github.com/riscv-non-isa/riscv-arch-test),
provide a fundamental set of tests that can be used to verify that the behavior of the
RISC-V model aligns with RISC-V standards while executing specific applications.
These tests are not meant to replace thorough design verification.

Reference signatures are generated by the formal RISC-V model [RISC-V SAIL](https://github.com/riscv/sail-riscv)
in Executable and Linkable Format (ELF) files.
ELF files contain multiple testing instructions, data, and signatures, such as `cadd-01.elf`.
The specific data locations that the testing model (this emulator) must write to during
the test are referred to as test signatures.
These test signatures are written upon completion of the test and are then compared to the reference signature.
Successful tests are indicated by matching signatures.

To install [RISCOF](https://riscof.readthedocs.io/en/stable/installation.html#install-riscof):
```shell
$ python3 -m pip install git+https://github.com/riscv/riscof
```

[RISC-V GNU Compiler Toolchain](https://github.com/riscv-collab/riscv-gnu-toolchain) should be prepared in advance.
You can obtain prebuilt GNU toolchain for `riscv32-elf` from the [Automated Nightly Release](https://github.com/riscv-collab/riscv-gnu-toolchain/releases).
Then, run the following command:
```shell
$ make arch-test
```

For macOS users, installing `sdiff` might be required:
```shell
$ brew install diffutils
```

To run the tests for specific extension, set the environmental variable `RISCV_DEVICE` to one of `I`, `M`, `A`, `F`, `C`, `Zifencei`, `privilege`.
```shell
$ make arch-test RISCV_DEVICE=I
```

Current progress of this emulator in riscv-arch-test (RV32):
* Passed Tests
    - `I`: Base Integer Instruction Set
    - `M`: Standard Extension for Integer Multiplication and Division
    - `A`: Standard Extension for Atomic Instructions
    - `F`: Standard Extension for Single-Precision Floating-Point
    - `C`: Standard Extension for Compressed Instruction
    - `Zifencei`: Instruction-Fetch Fence
    - `privilege`: RISCV Privileged Specification

Detail in riscv-arch-test:
* [RISCOF document](https://riscof.readthedocs.io/en/stable/)
* [riscv-arch-test repository](https://github.com/riscv-non-isa/riscv-arch-test)
* [RISC-V Architectural Testing Framework](https://github.com/riscv-non-isa/riscv-arch-test/blob/master/doc/README.adoc)
* [RISC-V Architecture Test Format Specification](https://github.com/riscv-non-isa/riscv-arch-test/blob/master/spec/TestFormatSpec.adoc)

## Benchmarks

The benchmarks are classified into three categories based on their characteristics:
| Category                 | Benchmark  | Description |
| -------------------------| ---------- | ----------- |
| Computing intensive      | puzzle     | A sliding puzzle where numbered square tiles are arranged randomly with one tile missing, designed for solving the N-puzzle problem. |
|                          | Pi         | Calculates the millionth digit of π. |
|                          | miniz      | Compresses and decompresses 8 MiB of data. |
|                          | primes     | Finds the largest prime number below 33333333. |
|                          | sha512     | Computes the SHA-512 hash of 64 MiB of data. |
| I/O intensive            | Richards   | An OS task scheduler simulation benchmark for comparing system implementations. |
|                          | Dhrystone  | Evaluates string operations, involves frequent memory I/O, and generates the performance metric. |
| Computing and I/O Hybrid | Mandelbrot | A benchmark based on the Mandelbrot set, which uses fixed-point arithmetic and involves numerous integer operations. |
|                          | AES        | Includes 23 encryption and decryption algorithms adhering to the Advanced Encryption Standard. |
|                          | Nqueens    | A puzzle benchmark where n queens are placed on an n × n chessboard without attacking each other, using deep recursion for execution. |
|                          | qsort      | Sorts an array with 50 million items. |

These benchmarks performed by rv32emu (interpreter-only mode) and [Spike](https://github.com/riscv-software-src/riscv-isa-sim) v1.1.0. Ran on Intel Core i7-11700 CPU running at 2.5 GHz and an Ampere [eMAG](https://en.wikichip.org/wiki/ampere_computing/emag) 8180
microprocessor equipped with 32 Arm64 cores, capable of speeds up to 3.3 GHz. Both systems ran Ubuntu Linux 22.04.1 LTS. We utilized gcc version 12.3, configured as riscv32-unknown-elf-gcc.

The figures below illustrate the normalized execution time of rv32emu and Spike, where **the shorter indicates better performance**.

_x86-64_
![](docs/interp-bench-x64.png)

_Arm64_
![](docs/interp-bench-arm64.png)

### Continuous Benchmarking

Continuous benchmarking is integrated into GitHub Actions,
allowing the committer and reviewer to examine the comment on benchmark comparisons between
the pull request commit(s) and the latest commit on the master branch within the conversation.
This comment is generated by the benchmark CI and provides an opportunity for discussion before merging.

The results of the benchmark will be rendered on a [GitHub page](https://sysprog21.github.io/rv32emu-bench/).
Check [benchmark-action/github-action-benchmark](https://github.com/benchmark-action/github-action-benchmark) for the reference of benchmark CI workflow.

There are several files that have the potential to significantly impact the performance of `rv32emu`, including:
* `src/decode.c`
* `src/rv32_template.c`
* `src/emulate.c`

As a result, any modifications made to these files will trigger the benchmark CI.

## GDB Remote Debugging

`rv32emu` is permitted to operate as gdbstub in an experimental manner since it supports
a limited number of [GDB Remote Serial Protocol](https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html) (GDBRSP).
To enable this feature, you need to build the emulator and set `ENABLE_GDBSTUB=1` when running the `make` command.
After that, you might execute it using the command below.
```shell
$ build/rv32emu -g <binary>
```

The `<binary>` should be the ELF file in RISC-V 32 bit format. Additionally, it is advised
that you compile programs with the `-g` option in order to produce debug information in
your ELF files.

You can run `riscv-gdb` if the emulator starts up correctly without an error. It takes two
GDB commands to connect to the emulator after giving GDB the supported architecture of the
emulator and any debugging symbols it may have.

```shell
$ riscv32-unknown-elf-gdb
(gdb) file <binary>
(gdb) target remote :1234
```

Congratulate yourself if `riscv-gdb` does not produce an error message. Now that the GDB
command line is available, you can communicate with `rv32emu`.

### Dump registers as JSON

If the `-d [filename]` option is provided, the emulator will output registers in JSON format.
This feature can be utilized for tests involving the emulator, such as compiler tests.

You can also combine this option with `-q` to directly use the output.
For example, if you want to read the register x10 (a0), then run the following command:
```shell
$ build/rv32emu -d - -q out.elf | jq .x10
```

## Usage Statistics

### RISC-V Instructions/Registers

This is a static analysis tool for assessing the usage of RV32 instructions/registers
in a given target program.
Build this tool by running the following command:
```shell
$ make tool
```

After building, you can launch the tool using the following command:
```shell
$ build/rv_histogram [-ar] [target_program_path]
```

The tool includes two optional options:
* `-a`: output the analysis in ascending order(default is descending order)
* `-r`: output usage of registers(default is usage of instructions)

_Example Instructions Histogram_
![Instructions Histogram Example](docs/histogram-insn.png)

_Example Registers Histogram_
![Registers Histogram Example](docs/histogram-reg.png)

### Basic Block

To install [lolviz](https://github.com/parrt/lolviz), use the following command:
```shell
$ pip install lolviz
```

For macOS users, it might be necessary to install additional dependencies:
```shell
$ brew install graphviz
```

Build the profiling data by executing `rv32emu`.
This can be done as follows:
```shell
$ build/rv32emu -p build/[test_program].elf
```

To analyze the profiling data, use the `rv_profiler` tool with the desired options:
```shell
$ tools/rv_profiler [--start-address|--stop-address|--graph-ir] [test_program]
```

## WebAssembly Translation
### Build and run
`rv32emu` relies on [Emscripten](https://emscripten.org/docs/getting_started/downloads.html) to be compiled to WebAssembly. Thus, the target system should have
the Emscripten version 3.1.51 installed.

Moreover, `rv32emu` leverages the tail call optimization(TCO) strategy and we have tested the WebAssembly
execution in Chrome with at least MAJOR 112 and Firefox with at least MAJOR 121 since they supports
tail call feature. Thus, please check and update your browsers if necessary or install the suitable browsers
before going further.

Source your Emscripten SDK environment before make. For macOS and Linux user:
```shell
$ source ~/emsdk/emsdk_env.sh
```
Change the Emscripten SDK environment path if necessary.

At this point, you can build and start a web server service to serve WebAssembly by running:
```shell
$ make CC=emcc start-web
```
You would see the server's IP:PORT in your terminal. Copy and paste it to the browsers and
you just access the index page of `rv32emu`.

### Index page
You would see a dropdown menu which you can use to select the ELF executable. Select one and
click the Run button to run it.

Alternatively, you may want to view a hosted `rv32emu` [demo page](https://sysprog21.github.io/rv32emu-demo/) since building takes some time.

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for contribution guidelines.

## License

`rv32emu` is available under a permissive MIT-style license.
Use of this source code is governed by a MIT license that can be found in the [LICENSE](LICENSE) file.

## External sources

In `rv32emu` repository, there are some prebuilt ELF files for testing purpose.
* `aes.elf` : See [tests/aes.c](tests/aes.c)
* `captcha.elf` : See [tests/captcha.c](tests/captcha.c)
* `cc.elf` : See [tests/cc](tests/cc)
* `chacha20.elf` : See [tests/chacha20](tests/chacha20)
* `coremark.elf` : See [eembc/coremark](https://github.com/eembc/coremark) [RV32M]
* `dhrystone.elf` : See [rv8-bench](https://github.com/michaeljclark/rv8-bench)
* `donut.elf` : See [donut.c](tests/donut.c)
* `doom.elf` : See [sysprog21/doom_riscv](https://github.com/sysprog21/doom_riscv) [RV32M]
* `fcalc.elf` : See [fcalc.c](tests/fcalc.c)
* `hamilton.elf` : See [hamilton.c](tests/hamilton.c)
* `ieee754.elf` : See [tests/ieee754.c](tests/ieee754.c) [RV32F]
* `jit-bf.elf` : See [ezaki-k/xkon_beta](https://github.com/ezaki-k/xkon_beta)
* `lena.elf`: See [tests/lena.c](tests/lena.c)
* `line.elf` : See [tests/line.c](tests/line.c) [RV32M]
* `maj2random.elf` : See [tests/maj2random.c](tests/maj2random.c) [RV32F]
* `mandelbrot.elf` : See [tests/mandelbrot.c](tests/mandelbrot.c)
* `nqueens.elf` : See [tests/nqueens.c](tests/nqueens.c)
* `nyancat.elf` : See [tests/nyancat.c](tests/nyancat.c)
* `pi.elf` : See [tests/pi.c](tests/pi.c) [RV32M]
* `qrcode.elf` : See [tests/qrcode.c](tests/qrcode.c)
* `quake.elf` : See [sysprog21/quake-embedded](https://github.com/sysprog21/quake-embedded) [RV32F]
* `readelf.elf` : See [tests/readelf](tests/readelf)
* `richards.elf` : See [tests/richards.c](tests/richards.c)
* `rvsim.elf` : See [tests/rvsim.c](tests/rvsim.c)
* `scimark2.elf` : See [tests/scimark2](tests/scimark2) [RV32MF]
* `smolnes.elf` : See [tests/smolnes](tests/smolnes.c) [RV32M]
* `spirograph.elf` : See [tests/spirograph.c](tests/spirograph.c)
* `stream.elf` : See [tests/stream](tests/stream.c) [RV32MF]
* `qsort.elf` : See [rv8-bench](https://github.com/michaeljclark/rv8-bench)
* `miniz.elf` : See [rv8-bench](https://github.com/michaeljclark/rv8-bench)
* `primes.elf` : See [rv8-bench](https://github.com/michaeljclark/rv8-bench)
* `sha512.elf` : See [rv8-bench](https://github.com/michaeljclark/rv8-bench)
* `numeric_sort.elf` : See [nbench](https://github.com/nfinit/ansibench/tree/master/nbench)
* `FP_emulation.elf` : See [nbench](https://github.com/nfinit/ansibench/tree/master/nbench)
* `bitfield.elf` : See [nbench](https://github.com/nfinit/ansibench/tree/master/nbench)
* `idea.elf` : See [nbench](https://github.com/nfinit/ansibench/tree/master/nbench) 
* `assignment.elf` : See [nbench](https://github.com/nfinit/ansibench/tree/master/nbench)
* `string_sort.elf` : See [nbench](https://github.com/nfinit/ansibench/tree/master/nbench) 
* `huffman.elf` : See [nbench](https://github.com/nfinit/ansibench/tree/master/nbench)
## Reference

* [Writing a simple RISC-V emulator in plain C](https://fmash16.github.io/content/posts/riscv-emulator-in-c.html)
* [Writing a RISC-V Emulator in Rust](https://book.rvemu.app/)
* [Bare metal C on my RISC-V toy CPU](https://florian.noeding.com/posts/risc-v-toy-cpu/cpu-from-scratch/)
* [Juraj's RISC-V note](https://jborza.com/tags/riscv/)
* [libriscv: RISC-V userspace emulator library](https://github.com/fwsGonzo/libriscv)
* [GUI-VP: RISC-V based Virtual Prototype (VP) for graphical application development](https://github.com/ics-jku/GUI-VP)
* [LupV: an education-friendly RISC-V based system emulator](https://gitlab.com/luplab/lupv)
* [mini-rv32ima](https://github.com/cnlohr/mini-rv32ima) / [video: Writing a Really Tiny RISC-V Emulator](https://youtu.be/YT5vB3UqU_E)
* [RVVM](https://github.com/LekKit/RVVM)
